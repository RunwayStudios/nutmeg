// Make sure this file is not included twice
#ifndef PYRAMIDFACES_INCLUDED
#define PYRAMIDFACES_INCLUDED

// Include helper functions from URP
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "NMGGeometryHelpers.hlsl"

// This structure is created by the renderer and passed to the Vertex function
// It holds data stored on the model, per vertex
struct Attributes
{
    //float2 normalOS     : NORMAL;
    float3 positionOS : POSITION; // Position in object space
    //float2 uv           : TEXCOORD0; // UVs
};

// Other common semantics include NORMAL, TANGENT, COLOR

// This structure is generated by the vertex function and passed to the geometry function
struct VertexOutput
{
    float3 positionWS : TEXCOORD0; // Position in world space
    //float2 uv           : TEXCOORD1; // UVs
};

// This structure is generated by the geometry function and passed to the fragment function
// Remember the renderer averages these values between the three points on the triangle 
struct GeometryOutput
{
    float3 positionWS : TEXCOORD0; // Position in world space
    float3 normalWS : TEXCOORD1; // Normal vector in world space
    //float3 diff : TEXCOORD2;
    //float2 uv                       : TEXCOORD2; // UVs

    float4 positionCS : SV_POSITION; // Position in clip space

};

// The _MainTex property. The sampler and scale/offset vector is also created
//TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); float4 _MainTex_ST;
// The pyramid height property
//float _PyramidHeight;

// color of the terrain
float3 _TerrainColor;

// Vertex functions

VertexOutput Vertex(Attributes input)
{
    // Initialize an output struct
    VertexOutput output = (VertexOutput)0;

    // Use this URP functions to convert position to world space
    // The analogous function for normals is GetVertexNormalInputs
    //VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);
    //output.positionWS = vertexInput.positionWS;
    output.positionWS = TransformObjectToWorld(input.positionOS);


    // TRANSFORM_TEX is a macro which scales and offsets the UVs based on the _MainTex_ST variable
    //output.uv = TRANSFORM_TEX(input.uv, _MainTex);
    return output;
}

// Geometry functions

GeometryOutput SetupVertex(float3 positionWS, float3 normalWS/*, float2 uv*/)
{
    // Setup an output struct
    GeometryOutput output = (GeometryOutput)0;
    output.positionWS = positionWS;
    output.normalWS = normalWS;
    
    
    //output.diff = _TerrainColor.rgb * normalWS;


    //output.uv = uv;
    // This function calculates clip space position, taking the shadow caster pass into account
    output.positionCS = CalculatePositionCSWithShadowCasterLogic(positionWS, normalWS);
    return output;
}

// void SetupAndOutputTriangle(inout TriangleStream<GeometryOutput> outputStream, VertexOutput a, VertexOutput b, VertexOutput c) {
//     // Restart the triangle strip, signaling the next appends are disconnected from the last
//     outputStream.RestartStrip();
//     // Since we extrude the center face, the normal must be recalculated
//     float3 normalWS = GetNormalFromTriangle(a.positionWS, b.positionWS, c.positionWS);
//     // Add the output data to the output stream, creating a triangle
//     outputStream.Append(SetupVertex(a.positionWS, normalWS, a.uv));
//     outputStream.Append(SetupVertex(b.positionWS, normalWS, b.uv));
//     outputStream.Append(SetupVertex(c.positionWS, normalWS, c.uv));
// }

// We create three triangles from one, so there will be 9 vertices
[maxvertexcount(3)]
void Geometry(triangle VertexOutput inputs[3], inout TriangleStream<GeometryOutput> outputStream)
{
    // Create a fake VertexOutput for the center vertex
    //VertexOutput center = (VertexOutput)0;
    // We need the triangle's normal to extrude the center point
    const float3 triNormal = GetNormalFromTriangle(inputs[0].positionWS, inputs[1].positionWS, inputs[2].positionWS);

    // Find the center position and extrude by _PyramidHeight along the normal
    //center.positionWS = GetTriangleCenter(inputs[0].positionWS, inputs[1].positionWS, inputs[2].positionWS) + triNormal * _PyramidHeight;
    // Average the UVs as well
    //center.uv = GetTriangleCenter(inputs[0].uv, inputs[1].uv, inputs[2].uv);

    // Create the three triangles.
    // Triangles must wind clockwise or they will not render by default
    //SetupAndOutputTriangle(outputStream, inputs[0], inputs[1], inputs[2]);
    //SetupAndOutputTriangle(outputStream, inputs[1], inputs[2], center);
    //SetupAndOutputTriangle(outputStream, inputs[2], inputs[0], center);

    // Restart the triangle strip, signaling the next appends are disconnected from the last
    //outputStream.RestartStrip();
    // Since we extrude the center face, the normal must be recalculated
    //float3 normalWS = GetNormalFromTriangle(a.positionWS, b.positionWS, c.positionWS);
    // Add the output data to the output stream, creating a triangle
    outputStream.Append(SetupVertex(inputs[0].positionWS, triNormal));
    outputStream.Append(SetupVertex(inputs[1].positionWS, triNormal));
    outputStream.Append(SetupVertex(inputs[2].positionWS, triNormal));
}

// Fragment functions

// The SV_Target semantic tells the compiler that this function outputs the pixel color
float4 Fragment(GeometryOutput input) : SV_Target
{
    #ifdef SHADOW_CASTER_PASS
    // If in the shadow caster pass, we can just return now
    // It's enough to signal that should will cast a shadow
    return 0;
    #else
    // Initialize some information for the lighting function
    InputData lightingInput = (InputData)0;
    lightingInput.positionWS = input.positionWS;
    lightingInput.normalWS = input.normalWS; // No need to renormalize, since triangles all share normals
    lightingInput.viewDirectionWS = GetViewDirectionFromPosition(input.positionWS);
    lightingInput.shadowCoord = CalculateShadowCoord(input.positionWS, input.positionCS);

    // Read the main texture
    //float3 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv).rgb;

    // Call URP's simple lighting function
    // The arguments are lightingInput, albedo color, specular color, smoothness, emission color, and alpha
    //return float4(_TerrainColor, 1);
    
    // half alpha = 1;
    // BRDFData brdfData;
    //
    // //                 albedo, metallic, specular, smoothness, alpha
    // InitializeBRDFData(_TerrainColor.rgb, 0, 1, 0.1, alpha, brdfData);
    //
    // //                     brdfData, indirectDiffuse, indirectSpecular, fresnelTerm
    //
    // SurfaceData s;
    // s.albedo              = _TerrainColor.rgb;
    // s.metallic            = 0;
    // s.specular            = 0;
    // s.smoothness          = 0;
    // s.occlusion           = 0;
    // s.emission            = 0;
    // s.alpha               = 1;
    // s.clearCoatMask       = 0.0;
    // s.clearCoatSmoothness = 1.0;
    
    //return UniversalFragmentPBR(lightingInput, s);
    
    //return float4(EnvironmentBRDF(brdfData, 1, 1, 1),1);

    
    half4 shadowMask = half4(1, 1, 1, 1);
    Light mainLight = GetMainLight(lightingInput.shadowCoord, input.positionWS, shadowMask);

    
    half nl = max(0, dot(input.normalWS, _MainLightPosition.xyz));
    half4 diff = nl * _MainLightColor;
    diff.rgb += SampleSH(input.normalWS);

    diff.rgb = SampleSH(input.normalWS);
    diff.a = 1;
    
    float4 col = float4(_TerrainColor.rgb, 1);
    col *= diff;
    return diff;
    
//     return UniversalFragmentBlinnPhong(lightingInput, _TerrainColor.rgb, 0, 0, 0, 1) + ;
//
//
//     InputData inputData = lightingInput;
//     half3 diffuse = _TerrainColor.rgb;
//     half4 specularGloss = 0;
//     half smoothness = 0;
//     half3 emission = 0;
//     half alpha = 1;
//
//
//     
// // To ensure backward compatibility we have to avoid using shadowMask input, as it is not present in older shaders
// // #if defined(SHADOWS_SHADOWMASK) && defined(LIGHTMAP_ON)
// //     half4 shadowMask = inputData.shadowMask;
// // #elif !defined (LIGHTMAP_ON)
// //     half4 shadowMask = unity_ProbesOcclusion;
// // #else
//      half4 shadowMask = half4(0, 0, 0, 0);
// // #endif
//
//     Light mainLight = GetMainLight(inputData.shadowCoord, inputData.positionWS, shadowMask);
//
//     #if defined(_SCREEN_SPACE_OCCLUSION)
//         AmbientOcclusionFactor aoFactor = GetScreenSpaceAmbientOcclusion(inputData.normalizedScreenSpaceUV);
//         mainLight.color *= aoFactor.directAmbientOcclusion;
//         inputData.bakedGI *= aoFactor.indirectAmbientOcclusion;
//     #endif
//
//     MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI);
//
//     half3 attenuatedLightColor = mainLight.color * (mainLight.distanceAttenuation * mainLight.shadowAttenuation);
//     half3 diffuseColor = inputData.bakedGI + LightingLambert(attenuatedLightColor, mainLight.direction, inputData.normalWS);
//     half3 specularColor = LightingSpecular(attenuatedLightColor, mainLight.direction, inputData.normalWS, inputData.viewDirectionWS, specularGloss, smoothness);
//
// #ifdef _ADDITIONAL_LIGHTS
//     uint pixelLightCount = GetAdditionalLightsCount();
//     for (uint lightIndex = 0u; lightIndex < pixelLightCount; ++lightIndex)
//     {
//         Light light = GetAdditionalLight(lightIndex, inputData.positionWS, shadowMask);
//         #if defined(_SCREEN_SPACE_OCCLUSION)
//             light.color *= aoFactor.directAmbientOcclusion;
//         #endif
//         half3 attenuatedLightColor = light.color * (light.distanceAttenuation * light.shadowAttenuation);
//         diffuseColor += LightingLambert(attenuatedLightColor, light.direction, inputData.normalWS);
//         specularColor += LightingSpecular(attenuatedLightColor, light.direction, inputData.normalWS, inputData.viewDirectionWS, specularGloss, smoothness);
//     }
// #endif
//
// #ifdef _ADDITIONAL_LIGHTS_VERTEX
//     diffuseColor += inputData.vertexLighting;
// #endif
//
//     half3 finalColor = diffuseColor * diffuse + emission;
//
// #if defined(_SPECGLOSSMAP) || defined(_SPECULAR_COLOR)
//     finalColor += specularColor;
// #endif
//
//     return half4(finalColor, alpha);
//
//     
//     //return float4(0, 1, 0, 1);
    #endif
}

#endif
